"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Shared = exports.SessionData = exports.HTTPTracerDelegator = exports.HTTPSemantic = void 0;
exports.extractSessionIdFromUrl = extractSessionIdFromUrl;
exports.newHttpInstrumantationConfig = newHttpInstrumantationConfig;

const http = require('http');

const {
  HttpInstrumentation
} = require('@opentelemetry/instrumentation-http');

const {
  ExpressInstrumentation
} = require('@opentelemetry/instrumentation-express');

const {
  Delegator
} = require('../appium');

const {
  Semantic
} = require('./semantic.js');

const {
  telemetry,
  capabilitiesToAttributes
} = require('../telemetry');

const {
  log
} = require('../logger');

const SESSIONID_RE = /\/session\/([^/\s]+)/;
const SESSION_CREATE_URL_RE = /\/session$/;
const SESSION_DELETE_URL_RE = /\/session\/([^/\s]+)$/;

function extractSessionIdFromUrl(url) {
  const m = url.match(SESSIONID_RE);

  if (!m || m.length !== 2) {
    return null;
  }

  return m[1];
}

function isCreateSessionRequest(req) {
  if (!(req instanceof http.IncomingMessage)) {
    return false;
  }

  if (!SESSION_CREATE_URL_RE.test(req.url)) {
    return false;
  }

  if (req.method !== 'POST') {
    return false;
  }

  return true;
}

function isDeleteSessionRequest(req) {
  if (!(req instanceof http.IncomingMessage)) {
    return false;
  }

  if (!SESSION_DELETE_URL_RE.test(req.url)) {
    return false;
  }

  if (req.method !== 'DELETE') {
    return false;
  }

  return true;
}

class SessionData {
  constructor(attributes) {
    this.attributes = attributes;
  }

  getAttributes() {
    return this.attributes;
  }

}

exports.SessionData = SessionData;

class Shared {
  constructor(attributes = {}) {
    this.sessionDataStore = {};
    this.lastCreateSessionSpan = null;
    this.attributes = attributes;
  }

  getSessionData(sessionId) {
    return this.sessionDataStore[sessionId];
  }

  putLastSessionSpan(span) {
    this.lastCreateSessionSpan = span;
  }

  bindSessionAttributesToSpan(span, sessionId) {
    if (!sessionId) {
      return;
    }

    const data = this.getSessionData(sessionId);

    if (!data) {
      log.info(`session information not found for session id: ${sessionId}.`);
      return;
    }

    const attr = Object.assign({}, this.attributes, data.getAttributes());
    span.setAttributes(attr);
  }

  addSession(sessionId, data) {
    this.sessionDataStore[sessionId] = data;

    if (this.lastCreateSessionSpan) {
      this.bindSessionAttributesToSpan(this.lastCreateSessionSpan, sessionId);
      this.lastCreateSessionSpan = null;
    }
  }

  deleteSessionData(sessionId) {
    delete this.sessionDataStore[sessionId];
  }

}

exports.Shared = Shared;

class HTTPTracerDelegator extends Delegator {
  constructor(attributesInCaps, sharedInstance) {
    super();
    this.attributesInCaps = attributesInCaps;
    this.shared = sharedInstance;
  }

  async delegateCreateSession(next, driver, jwpDesCaps, jwpReqCaps, caps) {
    const res = await next();

    if (!res || !res.value || res.value.length < 2) {
      log.info('skip saving session Id');
      return res;
    }

    const sessionId = res.value[0];
    const capabilities = res.value[1];
    const capAttrs = capabilitiesToAttributes(capabilities, this.attributesInCaps);
    const sessionAttributes = Object.assign({}, capAttrs, {
      [telemetry.ATTR_SESSION_ID]: sessionId
    });
    this.shared.addSession(sessionId, new SessionData(sessionAttributes));
    return res;
  }

}

exports.HTTPTracerDelegator = HTTPTracerDelegator;

function newHttpInstrumantationConfig(sharedInstance) {
  return {
    applyCustomAttributesOnSpan: (span, req, res) => {
      if (req instanceof http.IncomingMessage && res instanceof http.ServerResponse) {
        const sessionId = extractSessionIdFromUrl(req.url);

        if (!sessionId) {
          return;
        }

        sharedInstance.bindSessionAttributesToSpan(span, sessionId);

        if (isDeleteSessionRequest(req)) {
          sharedInstance.deleteSessionData(sessionId);
        }
      }
    },
    requestHook: (span, req) => {
      if (isCreateSessionRequest(req)) {
        sharedInstance.putLastSessionSpan(span);
      }
    },
    requireParentforIncomingSpans: false,
    requireParentforOutgoingSpans: false
  };
}

class HTTPSemantic extends Semantic {
  constructor(attributesInCaps, attributes) {
    super();
    this.attributesInCaps = attributesInCaps;
    this.shared = new Shared(attributes);
  }

  newDelegater(tracer) {
    return new HTTPTracerDelegator(this.attributesInCaps, this.shared);
  }

  instrumentations() {
    return [new ExpressInstrumentation(), new HttpInstrumentation(newHttpInstrumantationConfig(this.shard))];
  }

}

exports.HTTPSemantic = HTTPSemantic;