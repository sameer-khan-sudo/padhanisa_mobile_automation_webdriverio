"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelaxedCapsPlugin = void 0;
const lodash_1 = __importDefault(require("lodash"));
const plugin_1 = require("appium/plugin");
const STANDARD_CAPS = [
    'browserName',
    'browserVersion',
    'platformName',
    'acceptInsecureCerts',
    'pageLoadStrategy',
    'proxy',
    'setWindowRect',
    'timeouts',
    'unhandledPromptBehavior',
];
const VENDOR_PREFIX = 'appium';
const HAS_VENDOR_PREFIX_RE = /^.+:/;
class RelaxedCapsPlugin extends plugin_1.BasePlugin {
    /**
     * @param {any} caps
     * @returns {boolean}
     */
    isW3cCaps(caps) {
        if (!lodash_1.default.isPlainObject(caps)) {
            return false;
        }
        const isFirstMatchValid = () => lodash_1.default.isArray(caps.firstMatch) &&
            !lodash_1.default.isEmpty(caps.firstMatch) &&
            lodash_1.default.every(caps.firstMatch, lodash_1.default.isPlainObject);
        const isAlwaysMatchValid = () => lodash_1.default.isPlainObject(caps.alwaysMatch);
        if (lodash_1.default.has(caps, 'firstMatch') && lodash_1.default.has(caps, 'alwaysMatch')) {
            return isFirstMatchValid() && isAlwaysMatchValid();
        }
        if (lodash_1.default.has(caps, 'firstMatch')) {
            return isFirstMatchValid();
        }
        if (lodash_1.default.has(caps, 'alwaysMatch')) {
            return isAlwaysMatchValid();
        }
        return false;
    }
    addVendorPrefix(caps) {
        const newCaps = {};
        // if this doesn't look like a caps object just return it
        if (!lodash_1.default.isPlainObject(caps)) {
            return caps;
        }
        /** @type {string[]} */
        const adjustedKeys = [];
        for (const key of Object.keys(caps)) {
            if (STANDARD_CAPS.includes(key) || HAS_VENDOR_PREFIX_RE.test(key)) {
                // if the cap is a standard one, or if it already has a vendor prefix, leave it unchanged
                newCaps[key] = caps[key];
            }
            else {
                // otherwise add the appium vendor prefix
                newCaps[`${VENDOR_PREFIX}:${key}`] = caps[key];
                adjustedKeys.push(key);
            }
        }
        if (adjustedKeys.length) {
            this.logger.info(`Adjusted keys to conform to capability prefix requirements: ` +
                JSON.stringify(adjustedKeys));
        }
        return newCaps;
    }
    fixCapsIfW3C(caps) {
        const result = caps;
        if (result && this.isW3cCaps(result)) {
            if (lodash_1.default.isArray(result.firstMatch)) {
                result.firstMatch = caps.firstMatch.map(this.addVendorPrefix.bind(this));
            }
            if (lodash_1.default.isPlainObject(caps.alwaysMatch)) {
                result.alwaysMatch = this.addVendorPrefix(caps.alwaysMatch);
            }
        }
        ;
        return result;
    }
    /**
     * @param {Function} next
     * @param {import('appium/driver').BaseDriver} driver
     * @param {import('@appium/types').W3CDriverCaps} caps1
     * @param {import('@appium/types').W3CDriverCaps} [caps2]
     * @param {import('@appium/types').W3CDriverCaps} [caps3]
     * @param {any[]} restArgs
     * @returns
     */
    async createSession(next, driver, caps1, caps2, caps3, ...restArgs) {
        const patchedCaps = [caps1, caps2, caps3].map(this.fixCapsIfW3C.bind(this));
        // @ts-ignore We know what we are doing
        return await driver.createSession(...[...patchedCaps, ...restArgs]);
    }
}
exports.RelaxedCapsPlugin = RelaxedCapsPlugin;
//# sourceMappingURL=plugin.js.map