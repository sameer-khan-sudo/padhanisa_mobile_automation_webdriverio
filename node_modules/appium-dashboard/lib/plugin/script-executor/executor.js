"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriverScriptExecutor = void 0;
const child_process_1 = __importDefault(require("child_process"));
const support_1 = require("@appium/support");
const bluebird_1 = __importDefault(require("bluebird"));
const plugin_utils_1 = require("../utils/plugin-utils");
const childScript = require.resolve("./script.js");
const DEFAULT_SCRIPT_TIMEOUT_MS = 1000 * 60 * 60; // default to 1 hour timeout
class DriverScriptExecutor {
    constructor(sessionInfo, driver) {
        this.sessionInfo = sessionInfo;
        this.driver = driver;
        let { hostname, port, path } = (0, plugin_utils_1.getWdioServerOpts)(driver);
        this.driverOptions = {
            sessionId: sessionInfo.session_id,
            protocol: "http",
            hostname,
            port,
            path,
            isW3C: true,
            isMobile: true,
            capabilities: driver.caps,
        };
    }
    execute({ script, timeoutMs = DEFAULT_SCRIPT_TIMEOUT_MS }) {
        return __awaiter(this, void 0, void 0, function* () {
            const scriptProc = child_process_1.default.fork(childScript);
            let timeoutCanceled = false;
            try {
                const timer = new support_1.timing.Timer();
                timer.start();
                const waitForResult = () => __awaiter(this, void 0, void 0, function* () {
                    const res = yield new bluebird_1.default((res) => {
                        scriptProc.on("message", res); // this is node IPC
                    });
                    return res.data;
                });
                const waitForTimeout = () => __awaiter(this, void 0, void 0, function* () {
                    while (!timeoutCanceled && timer.getDuration().asMilliSeconds < timeoutMs) {
                        yield bluebird_1.default.delay(500);
                    }
                    if (timeoutCanceled) {
                        return;
                    }
                    throw new Error(`Execute driver script timed out after ${timeoutMs}ms. ` + `You can adjust this with the 'timeout' parameter.`);
                });
                scriptProc.send({ driverOpts: this.driverOptions, script, timeoutMs });
                // and set up a race between the response from the child and the timeout
                return yield bluebird_1.default.race([waitForResult(), waitForTimeout()]);
            }
            finally {
                // ensure we always cancel the timeout so that the timeout promise stops
                // spinning and allows this process to die gracefully
                timeoutCanceled = true;
                if (scriptProc.connected) {
                    scriptProc.disconnect();
                }
                if (scriptProc.exitCode === null) {
                    scriptProc.kill();
                }
            }
        });
    }
}
exports.DriverScriptExecutor = DriverScriptExecutor;
