"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const vm2_1 = require("vm2");
const support_1 = require("@appium/support");
const webdriverio_1 = require("webdriverio");
const log = support_1.logger.getLogger("ExecuteDriver Child");
let send;
function runScript(driverOpts, script, timeoutMs) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!lodash_1.default.isNumber(timeoutMs)) {
            throw new TypeError("Timeout parameter must be a number");
        }
        // set up fake logger
        const logLevels = ["error", "warn", "log"];
        const logs = [];
        const consoleFns = {};
        for (const level of logLevels) {
            consoleFns[level] = (...logMsgs) => logs.push({ level, message: [...logMsgs].map(parseLogMessage) });
        }
        const driver = yield (0, webdriverio_1.attach)(driverOpts);
        const fullScript = buildScript(script);
        log.info("Running driver script in Node vm");
        const vmCtx = new vm2_1.NodeVM({ timeout: timeoutMs });
        const vmFn = vmCtx.run(fullScript);
        // run the driver script, giving user access to the driver object, a fake
        // console logger, and a promise library
        let result = yield vmFn(driver, consoleFns, bluebird_1.default);
        //result = coerceScriptResult(result);
        log.info("Successfully ensured driver script result is appropriate type for return");
        return { result, logs };
    });
}
function parseLogMessage(log) {
    if (log instanceof Error) {
        return {
            message: log.message,
            stack: log.stack,
        };
    }
    return log;
}
/**
 * Embed a user-generated script inside a method which takes only the
 * predetermined objects we specify
 *
 * @param {string} script - the javascript to execute
 *
 * @return {string} - the full script to execute
 */
function buildScript(script) {
    return `module.exports = async function execute (driver, console, Promise) {
    ${script}
  }`;
}
function main(driverOpts, script, timeoutMs) {
    return __awaiter(this, void 0, void 0, function* () {
        let res;
        try {
            let { result, logs } = yield runScript(driverOpts, script, timeoutMs);
            if (result instanceof Error) {
                result = { error: true, message: result.message, stack: result.stack };
            }
            res = { result, logs };
        }
        catch (error) {
            console.log(error);
            res = { result: { error: true, message: error.message, stack: error.stack } };
        }
        yield send({
            data: res,
        });
    });
}
// ensure we're running this script in IPC mode
if (require.main === module && lodash_1.default.isFunction(process.send)) {
    send = bluebird_1.default.promisify(process.send, { context: process });
    log.info("Running driver execution in child process");
    process.on("message", ({ driverOpts, script, timeoutMs }) => {
        log.info("Parameters received from parent process");
        main(driverOpts, script, timeoutMs);
    });
}
