"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.terminateSession = exports.takeScreenShot = exports.getLogs = exports.getLogTypes = exports.stopScreenRecording = exports.startScreenRecording = void 0;
const plugin_utils_1 = require("./utils/plugin-utils");
function startScreenRecording(driver, sessionId, videoResolution) {
    return __awaiter(this, void 0, void 0, function* () {
        let resolution = "1280:720";
        let size = "1280x720";
        if (videoResolution) {
            resolution = videoResolution.replace("x", ":");
            size = videoResolution.replace(":", "x");
        }
        return yield (0, plugin_utils_1.makePostCall)(driver, sessionId, "/appium/start_recording_screen", {
            options: {
                videoType: "libx264",
                videoFps: 10,
                /* Force iOS video scale to fix '[ffmpeg] [libx264 @ 0x7fda5f005280] width not divisible by 2 (1125x2436)' */
                videoScale: resolution,
                /* Force Android size because some devices cannot record at their native resolution, resulting in error 'Unable to get output buffers (err=-38)' */
                videoSize: size,
                /* In android, adb can record only 3 mins of video. below timeLimit is used to take longer video */
                timeLimit: 1800, //in seconds (30 min)
            },
        });
    });
}
exports.startScreenRecording = startScreenRecording;
function takeScreenShot(driver, sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield (0, plugin_utils_1.makeGETCall)(driver, sessionId, "/screenshot");
    });
}
exports.takeScreenShot = takeScreenShot;
function stopScreenRecording(driver, sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield (0, plugin_utils_1.makePostCall)(driver, sessionId, "/appium/stop_recording_screen", {});
    });
}
exports.stopScreenRecording = stopScreenRecording;
function getLogTypes(driver, sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield (0, plugin_utils_1.makeGETCall)(driver, sessionId, "/log/types");
    });
}
exports.getLogTypes = getLogTypes;
function terminateSession(driver, sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield (0, plugin_utils_1.makeDELETECall)(driver, sessionId, "");
    });
}
exports.terminateSession = terminateSession;
function getLogs(driver, sessionId, logType) {
    var _a;
    let session = driver, logKey = {
        uiautomator2: "uiautomator2.adb.logcat.logs",
        xcuitest: "logs.syslog.logs",
    };
    if (driver.sessions) {
        session = driver.sessions[sessionId];
    }
    let logs = (_a = logKey[session.caps.automationName.toLowerCase()]) === null || _a === void 0 ? void 0 : _a.split(".").reduce((acc, k) => {
        return acc[k] || {};
    }, session);
    return Array.isArray(logs) ? logs : [];
}
exports.getLogs = getLogs;
