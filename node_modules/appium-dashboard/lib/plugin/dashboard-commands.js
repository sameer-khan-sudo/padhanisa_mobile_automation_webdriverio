"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashboardCommands = void 0;
const index_1 = require("../models/index");
const logger_1 = require("../loggers/logger");
class DashboardCommands {
    constructor(sessionInfo) {
        this.sessionInfo = sessionInfo;
    }
    /**
     * commandName: dashboard: setTestName
     */
    setTestName(args) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.info(`Updating test name for session ${args[0]}`);
            yield index_1.Session.update({
                name: args[0],
            }, {
                where: { session_id: this.sessionInfo.session_id },
            });
        });
    }
    /**
     * commandName: dashboard: debug
     */
    debug(args) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.info(`Adding debug logs for session ${this.sessionInfo.session_id}`);
            let props = args[0];
            yield index_1.Logs.create({
                session_id: this.sessionInfo.session_id,
                log_type: "DEBUG",
                message: props.message,
                args: props.args || null,
                timestamp: new Date(),
            });
        });
    }
    /**
     * commandName: dashboard: updateStatus
     */
    updateStatus(args) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.info(`Updating test status for session ${this.sessionInfo.session_id}`);
            let props = args[0];
            if (!props.status || !new RegExp(/passed|failed/g).test(props.status.toLowerCase())) {
                return;
            }
            yield index_1.Session.update({
                session_status_message: props.message,
                session_status: props.status.toUpperCase(),
                is_test_passed: props.status.toLowerCase() == "passed",
            }, {
                where: { session_id: this.sessionInfo.session_id },
            });
        });
    }
}
exports.DashboardCommands = DashboardCommands;
