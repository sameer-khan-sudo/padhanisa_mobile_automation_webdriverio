"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionManager = void 0;
const path = __importStar(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const plugin_utils_1 = require("./utils/plugin-utils");
const driver_command_executor_1 = require("./driver-command-executor");
const models_1 = require("../models");
const sequelize_1 = require("sequelize");
const logger_1 = require("../loggers/logger");
const plugin_logger_1 = require("../loggers/plugin-logger");
const fs = __importStar(require("fs"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const uuid_1 = require("uuid");
const dashboard_commands_1 = require("./dashboard-commands");
const session_timeout_tracker_1 = require("./session-timeout-tracker");
const database_service_1 = require("../database-service");
const session_debug_map_1 = __importDefault(require("./session-debug-map"));
const android_app_profiler_1 = require("./app-profiler/android-app-profiler");
const http_logs_1 = require("../models/http-logs");
const executor_1 = require("./script-executor/executor");
const CREATE_SESSION = "createSession";
class SessionManager {
    constructor(opts) {
        this.lastLogLine = 0;
        this.config = typedi_1.Container.get("config");
        this.httpLogsAvailable = false;
        this.sessionInfo = opts.sessionInfo;
        this.commandParser = opts.commandParser;
        this.cliArgs = opts.cliArgs;
        this.adb = opts.adb;
        logger_1.logger.info(`new command timeout ${this.sessionInfo.capabilities.newCommandTimeout}`);
        this.sessionInfo.is_completed = false;
        this.dashboardCommands = new dashboard_commands_1.DashboardCommands(this.sessionInfo);
        this.sessionTimeoutTracker = new session_timeout_tracker_1.SessionTimeoutTracker({
            timeout: this.sessionInfo.capabilities.newCommandTimeout || 300,
            pollingInterval: 1000,
            timeoutCallback: this.onSessionTimeOut.bind(this),
        });
        this.debugEventNotifier = typedi_1.Container.get("debugEventEmitter");
        this.resgisterEventListeners(this.debugEventNotifier);
        /* Check if the current session supports app profiling */
        if ((0, plugin_utils_1.isAppProfilingSupported)(this.sessionInfo) && this.adb) {
            plugin_logger_1.pluginLogger.info("Adb found. Creating device profiler");
            this.appProfiler = new android_app_profiler_1.AndroidAppProfiler({
                adb: this.adb.executable,
                deviceUDID: this.sessionInfo.udid,
                appPackage: this.sessionInfo.capabilities["appPackage"],
            });
        }
    }
    resgisterEventListeners(notifier) {
        let output = "";
        notifier.on(`${this.sessionInfo.session_id}`, (data) => __awaiter(this, void 0, void 0, function* () {
            try {
                switch (data.event) {
                    case "change_state":
                        session_debug_map_1.default.set(this.sessionInfo.session_id, {
                            is_paused: data.state == "pause",
                        });
                        yield models_1.Session.update({
                            is_paused: data.state == "pause",
                        }, {
                            where: {
                                session_id: this.sessionInfo.session_id,
                            },
                        });
                        break;
                    case "execute_driver_script":
                        if (this.driverScriptExecutor) {
                            output = yield this.driverScriptExecutor.execute({
                                script: data.script,
                                timeoutMs: data.timeout,
                            });
                        }
                        break;
                }
            }
            catch (err) {
                output = err;
            }
            this.sessionTimeoutTracker.tick();
            if (data.callback && lodash_1.default.isFunction(data.callback)) {
                data.callback(output);
            }
        }));
    }
    onCommandRecieved(command) {
        return __awaiter(this, void 0, void 0, function* () {
            if (command.commandName == CREATE_SESSION) {
                this.driver = command.driver;
                this.sessionTimeoutTracker.start();
                this.sessionTimeoutTracker.tick();
                return yield this.sessionStarted(command);
            }
            else if (command.commandName == "deleteSession") {
                this.sessionTimeoutTracker.stop();
                yield this.sessionTerminated();
            }
            else if (command.commandName == "execute" && (0, plugin_utils_1.isDashboardCommand)(this.dashboardCommands, command.args[0])) {
                yield this.executeCommand(command);
                return true;
            }
            else if (command.commandName == "proxyReqRes") {
                let promise = (0, plugin_utils_1.interceptProxyResponse)(command.args[1]);
                let originalNext = command.next;
                command.next = () => __awaiter(this, void 0, void 0, function* () { return (yield Promise.all([originalNext(), promise]))[1]; });
                Object.assign(command, Object.assign({}, (0, plugin_utils_1.routeToCommand)(command.args)));
                logger_1.logger.info(`Recieved proxyReqRes command for ${command.commandName}`);
            }
            this.sessionTimeoutTracker.tick();
            logger_1.logger.info(`New command recieved ${command.commandName} for session ${this.sessionInfo.session_id}`);
            yield this.saveServerLogs(command);
            try {
                command.startTime = new Date();
                let res = yield command.next();
                logger_1.logger.info(`Recieved response for command ${command.commandName} for session ${this.sessionInfo.session_id}`);
                command.endTime = new Date();
                yield this.postCommandExecuted(command, res);
                return res;
            }
            catch (err) {
                command.endTime = new Date();
                yield this.saveCommandLog(command, {
                    error: err.error,
                    message: err.message,
                });
                logger_1.logger.error(`Error occured while executing ${command.commandName} command ` +
                    JSON.stringify({
                        error: err.error,
                        message: err.message,
                    }));
                throw err;
            }
        });
    }
    postCommandExecuted(command, response) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            /* If the context is changed the webview, start http logging */
            if (!(response === null || response === void 0 ? void 0 : response.error) &&
                (0, plugin_utils_1.isAndroidSession)(this.sessionInfo) &&
                command.commandName == "setContext" &&
                command.args[0].includes("WEBVIEW")) {
                try {
                    yield ((_a = this.httpLogger) === null || _a === void 0 ? void 0 : _a.stop());
                    this.httpLogger = (0, plugin_utils_1.getHttpLogger)({
                        sessionInfo: this.sessionInfo,
                        adb: this.adb,
                        driver: this.driver,
                        isWebView: true,
                        webviewName: command.args[0],
                    });
                    yield this.httpLogger.start();
                    this.httpLogsAvailable = true;
                }
                catch (err) {
                    this.httpLogsAvailable = false;
                }
            }
            yield this.saveCommandLog(command, response);
        });
    }
    sessionStarted(command) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                session_debug_map_1.default.createNewSession(this.sessionInfo.session_id);
                this.driverScriptExecutor = new executor_1.DriverScriptExecutor(this.sessionInfo, command.driver);
                /* Check if the current session supports network profiling */
                if ((0, plugin_utils_1.isHttpLogsSuppoted)(this.sessionInfo)) {
                    plugin_logger_1.pluginLogger.info("Creating network profiler");
                    this.httpLogger = (0, plugin_utils_1.getHttpLogger)({
                        sessionInfo: this.sessionInfo,
                        adb: this.adb,
                        driver: command.driver,
                    });
                }
                let { desired } = this.sessionInfo.capabilities;
                let buildName = desired["dashboard:build"];
                let projectName = desired["dashboard:project"];
                let name = desired["dashboard:name"];
                let build, project;
                let { is_profiling_available, device_info } = yield this.startAppProfiling();
                yield this.startHttpLogsCapture();
                if (projectName) {
                    project = yield (0, database_service_1.getOrCreateNewProject)({ projectName });
                }
                if (buildName) {
                    build = yield (0, database_service_1.getOrCreateNewBuild)({ buildName, projectId: project === null || project === void 0 ? void 0 : project.id });
                }
                yield this.initializeScreenShotFolder();
                yield this.startScreenRecording(command.driver);
                yield models_1.Session.create(Object.assign(Object.assign({}, this.sessionInfo), { start_time: new Date(), build_id: build === null || build === void 0 ? void 0 : build.build_id, project_id: (project === null || project === void 0 ? void 0 : project.id) || null, device_info,
                    is_profiling_available, name: name || null, live_stream_port: yield (0, plugin_utils_1.getMjpegServerPort)(command.driver, this.sessionInfo.session_id) }));
                yield this.saveCommandLog(command, null);
            }
            catch (err) {
                logger_1.logger.error(`Error saving new session info in database for session ${this.sessionInfo.session_id}. response: ${JSON.stringify(err)}`);
            }
        });
    }
    sessionTerminated(options = { sessionTimedOut: false }) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveAppProfilingData();
            yield this.saveHttpLogs();
            let session = yield models_1.Session.findOne({
                where: {
                    session_id: this.sessionInfo.session_id,
                },
            });
            if (((_a = session === null || session === void 0 ? void 0 : session.session_status) === null || _a === void 0 ? void 0 : _a.toLowerCase()) == "timeout") {
                logger_1.logger.info(`Session ${this.sessionInfo.session_id} already timed out. So ignoring sessionTerminated command`);
                return;
            }
            this.sessionInfo.is_completed = true;
            let videoPath = yield this.saveScreenRecording(this.driver);
            let errorCount = yield models_1.CommandLogs.count({
                where: {
                    session_id: this.sessionInfo.session_id,
                    is_error: true,
                    command_name: {
                        [sequelize_1.Op.notIn]: ["findElement", "elementDisplayed"],
                    },
                },
            });
            let updateObject = {
                is_completed: true,
                is_paused: false,
                end_time: new Date(),
                video_path: videoPath || null,
                is_http_logs_available: this.httpLogsAvailable,
            };
            if (((_b = session === null || session === void 0 ? void 0 : session.session_status) === null || _b === void 0 ? void 0 : _b.toLowerCase()) == "running") {
                updateObject.session_status = options.sessionTimedOut ? "TIMEOUT" : errorCount > 0 ? "FAILED" : "PASSED";
            }
            if ((session === null || session === void 0 ? void 0 : session.is_test_passed) == null) {
                updateObject.is_test_passed = options.sessionTimedOut || errorCount > 0 ? false : true;
            }
            yield models_1.Session.update(updateObject, {
                where: {
                    session_id: this.sessionInfo.session_id,
                },
            });
            logger_1.logger.info(`Session terminated ${this.sessionInfo.session_id}`);
        });
    }
    saveServerLogs(command) {
        return __awaiter(this, void 0, void 0, function* () {
            let logs = (0, driver_command_executor_1.getLogs)(command.driver, this.sessionInfo.session_id, "server");
            let newLogs = logs.slice(this.lastLogLine);
            if (!newLogs.length) {
                return false;
            }
            this.lastLogLine = logs.length;
            yield models_1.Logs.bulkCreate(newLogs.map((l) => {
                return Object.assign(Object.assign({}, l), { timestamp: new Date(l.timestamp), session_id: this.sessionInfo.session_id, log_type: "DEVICE" });
            }));
            return true;
        });
    }
    saveCommandLog(command, response) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (typeof this.commandParser[command.commandName] == "function") {
                    response = command.commandName == CREATE_SESSION ? this.sessionInfo : response;
                    let parsedLog = yield this.commandParser[command.commandName](command.driver, command.args, response);
                    let screenShotPath = null;
                    if (this.config.takeScreenshotsFor.indexOf(command.commandName) >= 0) {
                        let screenShotbase64 = yield (0, driver_command_executor_1.takeScreenShot)(command.driver, this.sessionInfo.session_id);
                        if (screenShotbase64.value && typeof screenShotbase64.value === "string") {
                            screenShotPath = path.join(this.config.screenshotSavePath, this.sessionInfo.session_id, `${(0, uuid_1.v4)()}.jpg`);
                            fs.writeFileSync(screenShotPath, screenShotbase64.value, "base64");
                            logger_1.logger.info(`Screen shot saved for ${command.commandName} command in session ${this.sessionInfo.session_id}`);
                        }
                        else {
                            logger_1.logger.error(`Screen shot not saved for ${command.commandName} command in session ${this.sessionInfo.session_id} .response ${JSON.stringify(screenShotbase64.value)}`);
                        }
                    }
                    Object.assign(parsedLog, {
                        session_id: this.sessionInfo.session_id,
                        command_name: command.commandName,
                        is_error: response && !!response.error ? true : false,
                        screen_shot: screenShotPath,
                        start_time: command.startTime,
                        end_time: command.endTime,
                    });
                    yield models_1.CommandLogs.create(parsedLog);
                }
            }
            catch (err) {
                logger_1.logger.error(err);
            }
        });
    }
    startScreenRecording(driver) {
        return __awaiter(this, void 0, void 0, function* () {
            let { desired } = this.sessionInfo.capabilities;
            let videoResolution = desired["dashboard:videoResolution"];
            let sholdRecordVideo = lodash_1.default.isNil(desired["dashboard:enableVideoRecording"])
                ? true
                : desired["dashboard:enableVideoRecording"];
            if (sholdRecordVideo) {
                yield (0, driver_command_executor_1.startScreenRecording)(driver, this.sessionInfo.session_id, videoResolution);
            }
        });
    }
    initializeScreenShotFolder() {
        return __awaiter(this, void 0, void 0, function* () {
            let dirPath = path.join(this.config.screenshotSavePath, this.sessionInfo.session_id);
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath, { recursive: true });
            }
        });
    }
    saveScreenRecording(driver) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let videoBase64String = yield (0, driver_command_executor_1.stopScreenRecording)(driver, this.sessionInfo.session_id);
                if (videoBase64String.value != "" && typeof videoBase64String.value === "string") {
                    let outPath = path.join(this.config.videoSavePath, `${this.sessionInfo.session_id}.mp4`);
                    fs.writeFileSync(outPath, videoBase64String.value, "base64");
                    logger_1.logger.info(`Video saved for ${this.sessionInfo.session_id} in ${outPath}`);
                    return outPath;
                }
                else {
                    logger_1.logger.error(`Video not saved for session ${this.sessionInfo.session_id}. response: ${JSON.stringify(videoBase64String.value)}`);
                }
            }
            catch (err) {
                logger_1.logger.error(err);
            }
        });
    }
    executeCommand(command) {
        return __awaiter(this, void 0, void 0, function* () {
            let scriptName = command.args[0].split(":")[1].trim();
            yield this.dashboardCommands[scriptName](command.args[1]);
        });
    }
    onSessionTimeOut(timeoutValue) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.warn(`Session ${this.sessionInfo.session_id} timed out after ${timeoutValue} seconds`);
            yield this.saveCommandLog({
                driver: this.driver,
                startTime: new Date(),
                endTime: new Date(),
                commandName: "sessionTimedout",
                args: [timeoutValue],
                next: () => __awaiter(this, void 0, void 0, function* () { }),
            }, {});
            yield this.sessionTerminated({ sessionTimedOut: true });
            yield (0, driver_command_executor_1.terminateSession)(this.driver, this.sessionInfo.session_id);
        });
    }
    startAppProfiling() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.appProfiler) {
                try {
                    let device_info = yield ((_a = this.appProfiler) === null || _a === void 0 ? void 0 : _a.getDeviceInfo());
                    yield ((_b = this.appProfiler) === null || _b === void 0 ? void 0 : _b.startCapture());
                    return {
                        device_info,
                        is_profiling_available: true,
                    };
                }
                catch (err) {
                    plugin_logger_1.pluginLogger.error("Error initializing app profiler");
                    plugin_logger_1.pluginLogger.error(err);
                    return {
                        is_profiling_available: false,
                    };
                }
            }
            else {
                return {
                    is_profiling_available: false,
                };
            }
        });
    }
    saveAppProfilingData() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.appProfiler) {
                yield ((_a = this.appProfiler) === null || _a === void 0 ? void 0 : _a.stopCapture());
                let data = ((_b = this.appProfiler) === null || _b === void 0 ? void 0 : _b.getLogs()) || [];
                data = data.map((d) => {
                    return Object.assign(Object.assign({}, d), { session_id: this.sessionInfo.session_id });
                });
                yield models_1.Profiling.bulkCreate(data);
            }
        });
    }
    startHttpLogsCapture() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.httpLogger) {
                try {
                    yield this.httpLogger.start();
                    this.httpLogsAvailable = true;
                }
                catch (err) {
                    plugin_logger_1.pluginLogger.error("Error initializing network profiler");
                    plugin_logger_1.pluginLogger.error(err);
                    this.httpLogsAvailable = false;
                }
            }
            else {
                this.httpLogsAvailable = false;
            }
        });
    }
    saveHttpLogs() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.httpLogger) {
                try {
                    yield this.httpLogger.stop();
                    let logs = ((_a = this.httpLogger) === null || _a === void 0 ? void 0 : _a.getLogs()) || [];
                    let data = logs.map((l) => {
                        return Object.assign(Object.assign({}, l), { session_id: this.sessionInfo.session_id });
                    });
                    yield http_logs_1.HttpLogs.bulkCreate(data, {
                        validate: false,
                    });
                }
                catch (err) {
                    plugin_logger_1.pluginLogger.error("Unable to save http logs in database");
                    plugin_logger_1.pluginLogger.error(err);
                }
            }
        });
    }
}
exports.SessionManager = SessionManager;
