"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMjpegServerPort = exports.getHttpLogger = exports.isHttpLogsSuppoted = exports.isAppProfilingSupported = exports.isIOSSession = exports.getWdioServerOpts = exports.isAndroidSession = exports.isDashboardCommand = exports.millisToMinutesAndSeconds = exports.routeToCommand = exports.interceptProxyResponse = exports.getDriverEndpoint = exports.getSessionDetails = exports.makeDELETECall = exports.makePostCall = exports.makeGETCall = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const appium_base_driver_1 = require("appium-base-driver");
const android_http_logger_1 = require("../http-logger/android-http-logger");
const ios_http_logger_1 = require("../http-logger/ios-http-logger");
var PLATFORM;
(function (PLATFORM) {
    PLATFORM["ANDROID"] = "android";
    PLATFORM["IOS"] = "ios";
})(PLATFORM || (PLATFORM = {}));
function getSessionDetails(rawCapabilities, sessionResponse) {
    var _a, _b;
    let [session_id, caps] = sessionResponse.value;
    let sessionInfo = {
        session_id,
        platform: caps.platform || "",
        platform_name: ((_a = caps.platformName) === null || _a === void 0 ? void 0 : _a.toUpperCase()) || "",
        automation_name: caps.automationName || "",
        device_name: caps.deviceName || "",
        browser_name: caps.browserName || "",
        platform_version: caps.platformVersion || "",
        app: caps.app,
        udid: (((_b = caps.platformName) === null || _b === void 0 ? void 0 : _b.toLowerCase()) == "ios" ? caps.udid : caps.deviceUDID) || "",
        capabilities: Object.assign(Object.assign({}, caps), { desired: rawCapabilities }),
    };
    Object.keys(caps)
        .filter((k) => Object.keys(sessionInfo).indexOf(k) == -1)
        .forEach((k) => (sessionInfo.capabilities[k] = caps[k]));
    return sessionInfo;
}
exports.getSessionDetails = getSessionDetails;
function getDriverEndpoint(driver) {
    let { address, port, basePath } = driver.opts || driver;
    return `http://${address}:${port}${constructBasePath(basePath)}`;
}
exports.getDriverEndpoint = getDriverEndpoint;
function constructBasePath(basePath) {
    if (!basePath || basePath == "") {
        return "/wd-internal";
    }
    if (!basePath.startsWith("/")) {
        basePath = `/${basePath}`;
    }
    if (basePath.endsWith("/")) {
        basePath = basePath.substr(0, basePath.length - 2);
    }
    return `${basePath}/wd-internal`;
}
function makePostCall(driver, sessionId, path, body) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, node_fetch_1.default)(`${getDriverEndpoint(driver)}/session/${sessionId}${path}${getQueryString()}`, {
            method: "post",
            body: body ? JSON.stringify(body) : "{}",
            headers: { "Content-Type": "application/json" },
        });
        return yield response.json();
    });
}
exports.makePostCall = makePostCall;
function makeGETCall(driver, sessionId, path) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, node_fetch_1.default)(`${getDriverEndpoint(driver)}/session/${sessionId}${path}${getQueryString()}`);
        return yield response.json();
    });
}
exports.makeGETCall = makeGETCall;
function makeDELETECall(driver, sessionId, path) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, node_fetch_1.default)(`${getDriverEndpoint(driver)}/session/${sessionId}${path}${getQueryString()}`, {
            method: "delete",
        });
        return yield response.json();
    });
}
exports.makeDELETECall = makeDELETECall;
function getQueryString() {
    return "";
}
function interceptProxyResponse(response) {
    return new Promise((resolve, reject) => {
        const defaultWrite = response.write;
        const defaultEnd = response.end;
        const chunks = [];
        response.write = (...restArgs) => {
            chunks.push(Buffer.from(restArgs[0]));
            defaultWrite.apply(response, restArgs);
        };
        response.end = (...restArgs) => {
            if (restArgs[0]) {
                chunks.push(Buffer.from(restArgs[0]));
            }
            const body = Buffer.concat(chunks).toString("utf8");
            defaultEnd.apply(response, restArgs);
            resolve(JSON.parse(body).value);
        };
    });
}
exports.interceptProxyResponse = interceptProxyResponse;
function routeToCommand(proxyReqRes) {
    return {
        commandName: (0, appium_base_driver_1.routeToCommandName)(proxyReqRes[0].originalUrl, proxyReqRes[0].method),
        newargs: [proxyReqRes[0].body, proxyReqRes[proxyReqRes.length - 1]],
    };
}
exports.routeToCommand = routeToCommand;
function millisToMinutesAndSeconds(millis) {
    var minutes = Math.floor(millis / 60000);
    var seconds = ((millis % 60000) / 1000).toFixed(0);
    return `${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
}
exports.millisToMinutesAndSeconds = millisToMinutesAndSeconds;
function isDashboardCommand(dashboardCommand, commandName) {
    let parts = commandName.split(":").map((p) => p.trim());
    return parts[0] == "dashboard" && typeof dashboardCommand[parts[1]] == "function";
}
exports.isDashboardCommand = isDashboardCommand;
function isAndroidSession(sessionInfo) {
    return sessionInfo.platform_name.toLowerCase() == PLATFORM.ANDROID;
}
exports.isAndroidSession = isAndroidSession;
function isIOSSession(sessionInfo) {
    return sessionInfo.platform_name.toLowerCase() == PLATFORM.IOS;
}
exports.isIOSSession = isIOSSession;
function isAppProfilingSupported(sessionInfo) {
    return isAndroidSession(sessionInfo);
}
exports.isAppProfilingSupported = isAppProfilingSupported;
function isBrowser(sessionInfo) {
    return !!sessionInfo.browser_name;
}
function isHttpLogsSuppoted(sessionInfo) {
    return isAndroidSession(sessionInfo) && isBrowser(sessionInfo);
}
exports.isHttpLogsSuppoted = isHttpLogsSuppoted;
function getHttpLogger(opts) {
    let { sessionInfo, adb, driver, isWebView = false, webviewName = "" } = opts;
    if (isAndroidSession(sessionInfo)) {
        return new android_http_logger_1.AndroidNetworkProfiler({
            udid: sessionInfo.udid,
            adb,
            isWebView,
            webviewName,
        });
    }
    else {
        return new ios_http_logger_1.IosNetworkProfiler({
            udid: sessionInfo.udid,
            platformVersion: sessionInfo.platform_version,
        });
    }
}
exports.getHttpLogger = getHttpLogger;
function getMjpegServerPort(driver, sessionId) {
    var _a;
    const session = driver.sessions ? driver.sessions[sessionId] : driver;
    const portFinderPath = {
        uiautomator2: "opts.mjpegServerPort",
        xcuitest: "wda.mjpegServerPort",
    };
    const defaultPorts = {
        xcuitest: 9100,
    };
    const automationName = session.caps.automationName.toLowerCase();
    let mjpegServerPort = (_a = portFinderPath[automationName]) === null || _a === void 0 ? void 0 : _a.split(".").reduce((acc, k) => {
        return acc[k] || {};
    }, session);
    return typeof mjpegServerPort == "object" ? defaultPorts[automationName] : mjpegServerPort;
}
exports.getMjpegServerPort = getMjpegServerPort;
function getWdioServerOpts(driver) {
    let { address, port, basePath } = driver.opts || driver;
    return {
        hostname: address,
        port: port,
        path: constructBasePath(basePath),
    };
}
exports.getWdioServerOpts = getWdioServerOpts;
