"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IosNetworkProfiler = void 0;
const ios_utils_1 = require("../utils/ios-utils");
const appium_remote_debugger_1 = require("appium-remote-debugger");
const asyncbox_1 = require("asyncbox");
const lodash_1 = __importDefault(require("lodash"));
const plugin_logger_1 = require("../../loggers/plugin-logger");
const logger_1 = require("../../loggers/logger");
const SAFARI_BUNDLE_ID = "com.apple.mobilesafari";
/* TODO: Temporary solution. Need a better way to retrieve the socket path */
const DEFAULT_USBMUXD_SOCKET = "/var/run/usbmuxd";
const DEFAULT_USBMUXD_PORT = 27015;
const DEFAULT_USBMUXD_HOST = "127.0.0.1";
const DEFAULT_DEBUGGER_OPTIONS = {
    bundleId: SAFARI_BUNDLE_ID,
    isSafari: true,
    useNewSafari: true,
    pageLoadMs: 1000,
    garbageCollectOnExecute: false,
};
/**
 * TODO: Not working while appium session is active
 * Rewrite with new implementation
 */
class IosNetworkProfiler {
    constructor(options) {
        this.options = options;
        this.started = false;
        this.logs = {};
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const { udid, platformVersion } = this.options;
            if (!this.started) {
                this.remoteDebugger = yield IosNetworkProfiler.getRemoteDebugger(udid, platformVersion);
                try {
                    yield IosNetworkProfiler.waitForRemoteDebugger(this.remoteDebugger);
                    yield this.initializeListeners();
                    this.started = true;
                }
                catch (err) {
                    logger_1.logger.error("Unable to capture network data for ios device");
                    logger_1.logger.error(err);
                    yield this.stop();
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.started && this.remoteDebugger) {
                yield this.remoteDebugger.disconnect();
                this.started = false;
            }
        });
    }
    getLogs() {
        return [];
    }
    initializeListeners() {
        return __awaiter(this, void 0, void 0, function* () {
            this.remoteDebugger.addClientEventListener("NetworkEvent", (err, event) => {
                plugin_logger_1.pluginLogger.info(event);
                this.logs[event.requestId] = event;
            });
            this.remoteDebugger.addClientEventListener("Network.responseReceived", (err, event) => __awaiter(this, void 0, void 0, function* () {
                plugin_logger_1.pluginLogger.info(event);
                this.logs[event.requestId] = Object.assign({}, this.logs[event.requestId], {
                    response: event,
                });
            }));
            const page = lodash_1.default.find(yield this.remoteDebugger.selectApp("http://0.0.0.0:4723/welcome"), (page) => {
                return page.url == "http://0.0.0.0:4723/welcome";
            });
            const [appIdKey, pageIdKey] = page.id.split(".").map((id) => parseInt(id, 10));
            plugin_logger_1.pluginLogger.info(`AppId: ${appIdKey}  and pageIdKey: ${pageIdKey}`);
            //await this.remoteDebugger.selectPage(appIdKey, pageIdKey);
        });
    }
    static waitForRemoteDebugger(remoteDebugger) {
        return __awaiter(this, void 0, void 0, function* () {
            yield remoteDebugger.connect();
            yield (0, asyncbox_1.retryInterval)(30, 1000, () => __awaiter(this, void 0, void 0, function* () {
                if (!lodash_1.default.isEmpty(remoteDebugger.appDict)) {
                    return remoteDebugger.appDict;
                }
                yield remoteDebugger.setConnectionKey();
                throw new Error("No apps connected");
            }));
        });
    }
    static getRemoteDebugger(deviceUUID, platformVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield (0, ios_utils_1.isRealDevice)(deviceUUID)) {
                let options = Object.assign(Object.assign({}, DEFAULT_DEBUGGER_OPTIONS), { isSimulator: false, socketPath: DEFAULT_USBMUXD_SOCKET, uuid: deviceUUID, platformVersion });
                return (0, appium_remote_debugger_1.createRemoteDebugger)(options, true);
            }
            else {
                let simulator = yield (0, ios_utils_1.getSimulator)(deviceUUID);
                let options = Object.assign(Object.assign({}, DEFAULT_DEBUGGER_OPTIONS), { isSimulator: true, socketPath: yield simulator.getWebInspectorSocket(), uuid: deviceUUID, platformVersion });
                return (0, appium_remote_debugger_1.createRemoteDebugger)(options, false);
            }
        });
    }
}
exports.IosNetworkProfiler = IosNetworkProfiler;
