"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AndroidNetworkProfiler = void 0;
const teen_process_1 = require("teen_process");
const chrome_remote_interface_1 = __importDefault(require("chrome-remote-interface"));
const plugin_logger_1 = require("../../loggers/plugin-logger");
const http_log_parser_1 = require("./http-log-parser");
const http_status_1 = __importDefault(require("http-status"));
class AndroidNetworkProfiler {
    constructor(options) {
        this.options = options;
        this.started = false;
        this.logs = {};
        this.logParser = new http_log_parser_1.NetworkLogsParser(this.getContextName() || "");
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const { udid, adb, isWebView = false } = this.options;
            try {
                if (!this.started) {
                    this.remoteDebugger = yield this.getClient(adb.executable, udid, isWebView);
                    yield this.startListener(this.remoteDebugger);
                }
            }
            catch (err) {
                plugin_logger_1.pluginLogger.error("Unable to initialize android network profiler");
                plugin_logger_1.pluginLogger.error(err);
                this.started = false;
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.remoteDebugger && this.started) {
                yield this.remoteDebugger.close();
                this.started = false;
            }
        });
    }
    getLogs() {
        return this.logParser.getLogs();
    }
    startListener(remoteDebugger) {
        return __awaiter(this, void 0, void 0, function* () {
            const { Network } = remoteDebugger;
            Network.on("requestWillBeSent", this.logParser.onRequestRecieved.bind(this.logParser));
            Network.on("responseReceived", (params) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (params.type.toLowerCase() == "xhr") {
                    try {
                        let response = yield Network.getResponseBody({
                            requestId: params.requestId,
                        });
                        if (this.isResponseBodyValid(params.response.mimeType)) {
                            params.responseBody = this.parseResponseBody(response);
                        }
                        params.response.statusText = !!((_a = params.response) === null || _a === void 0 ? void 0 : _a.statusText)
                            ? (_b = params.response) === null || _b === void 0 ? void 0 : _b.statusText
                            : http_status_1.default[params.response.status];
                    }
                    catch (err) { }
                }
                this.logParser.onResponseRecieved(params);
            }));
            yield Network.enable({});
        });
    }
    getContextName() {
        return this.options.isWebView ? this.options.webviewName : "browser";
    }
    getClient(adb, udid, isWebView) {
        return __awaiter(this, void 0, void 0, function* () {
            const debuggerPort = yield this.getChromeDebuggerPort(adb, udid, isWebView);
            if (!!debuggerPort) {
                return yield (0, chrome_remote_interface_1.default)({
                    local: true,
                    port: debuggerPort,
                });
            }
            else {
                throw new Error(`No debugging port found for device ${udid}`);
            }
        });
    }
    getChromeDebuggerPort(adb, udid, isWebView) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = [...adb.defaultArgs, "-s", udid, "forward", "--list"];
            let portSelector = isWebView ? "localabstract:webview_devtools_remote" : "localabstract:chrome_devtools_remote";
            let portList = yield (0, teen_process_1.exec)(adb.path, args);
            plugin_logger_1.pluginLogger.info(portList.stdout);
            let portEntry = (_a = portList.stdout
                .split("\n")
                .filter((portEntry) => portEntry.includes(portSelector))
                .pop()) === null || _a === void 0 ? void 0 : _a.match(/tcp:([\d]{0,})/);
            return portEntry && portEntry.length > 1 ? parseInt(portEntry[1]) : null;
        });
    }
    isResponseBodyValid(responseType) {
        return !responseType.includes("javascript");
    }
    parseResponseBody(response) {
        return response.base64Encoded ? Buffer.from(response.body, "base64").toString("ascii") : response.body;
    }
}
exports.AndroidNetworkProfiler = AndroidNetworkProfiler;
