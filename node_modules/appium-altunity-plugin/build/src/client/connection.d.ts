/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import WebSocket from 'ws';
import B from 'bluebird';
export declare enum NotificationType {
    LOAD_SCENE = "LOAD_SCENE",
    UNLOAD_SCENE = "UNLOAD_SCENE",
    LOG = "LOG",
    APP_PAUSED = "APP_PAUSED"
}
export type ResponseError = {
    type: string;
    message: string;
    trace: string;
};
export type CommandParameters = {
    [key: string]: any;
};
export type BaseMessage = {
    commandName: string;
    messageId: string;
};
export type Message = CommandParameters & BaseMessage;
export type Response = BaseMessage & {
    data: any;
    error: ResponseError;
    isNotification: boolean;
};
export type ConnectionOpts = {
    log: any;
    host: string;
    port: number;
    commandTimeout?: number;
};
type MessageCallbacks = {
    [messageId: string]: {
        responseCount: number;
        validations: string[];
        cb: (responses: Response[]) => void;
        timerPromise: B<void>;
    };
};
export declare class NoConnectionError extends Error {
    constructor();
}
export declare class CommandTimeoutError extends Error {
    constructor(msgId: string, timeout: number);
}
export declare class ResponseValidationError extends Error {
    constructor(msgId: string, resIdx: number, expected: any, actual: any);
}
export declare class NotificationHandler extends EventEmitter {
    handle(message: Response): void;
}
export declare class Connection {
    protected log: any;
    protected host: string;
    protected port: number;
    protected ws: WebSocket | null;
    protected notificationHandler: NotificationHandler;
    protected messageCallbacks: MessageCallbacks;
    protected responseStore: {
        [messageId: string]: Response[];
    };
    protected closeCallback: (() => void) | null;
    private _commandTimeoutSecs;
    constructor(opts: ConnectionOpts);
    get commandTimeout(): number;
    set commandTimeout(secs: number);
    connect(): Promise<unknown>;
    handleIncomingMessage(jsonMessage: Buffer): Promise<void>;
    handleClose(): Promise<void>;
    sendMessage(message: Message, responseCount?: number, validations?: string[]): Promise<Response[]>;
    sendSimpleMessage(message: Message, validation?: string): Promise<Response>;
    close(): Promise<void>;
}
export {};
